#!/usr/bin/env python3
# -*- coding: utf-8 -*-

""" Python code to start a RIPE Atlas UDM (User-Defined
Measurement). This one is for running IPv4 or IPv6 traceroute queries
to analyze routing

You'll need an API key in ~/.atlas/auth.

St√©phane Bortzmeyer <stephane+frama@bortzmeyer.org>
"""

import json
import time
import os
import string
import sys
import time
import socket
import pickle as pickle

import Blaeu

# If we use --format:
# import cymruwhois

config = Blaeu.Config()
# Default values
config.protocol = "UDP"
config.format = False
config.do_lookup = False
config.do_reverse_lookup = False
config.size = None
config.first_hop = 1
config.max_hops = 32

def is_ip_address(str):
    try:
        addr = socket.inet_pton(socket.AF_INET6, str)
    except socket.error: # not a valid IPv6 address
        try:
            addr = socket.inet_pton(socket.AF_INET, str)
        except socket.error: # not a valid IPv4 address either
            return False
    return True

def lookup_hostname(str):
    try:
        info = socket.getaddrinfo(str, 0, socket.AF_UNSPEC, socket.SOCK_STREAM,0, socket.AI_PASSIVE)
        if len(info) > 1:
            print("%s returns more then one IP address please select one" % str)
            count=0
            for ip in info:
                count= count + 1    
                fa, socktype, proto, canonname, sa = ip
                print("%s - %s" % (count, sa[0]))
            selection=int(input("=>"))
            selection = selection - 1
            selected_ip=info[selection][4][0]
        else:
            selected_ip=info[0][4][0]
            print("Using IP: %s" % selected_ip)
    except socket.error:
        return False
    return selected_ip

def lookup_ip(ip):
    try:
        name, alias, addresslist = socket.gethostbyaddr(ip)
    except Exception as e:
        msg = "No PTR"
        return msg
    return name

def usage(msg=None):
    print("Usage: %s target-IP-address" % sys.argv[0], file=sys.stderr)
    config.usage(msg)
    print("""Also:
    --format or -b : downloads the results and format them in a traditional traceroute way
    --protocol=PROTO or -j PROTO : uses this protocol (UDP, TCP or ICMP, default is %s)
    --do_lookup : Enables IP lookup feature (default is disabled, may become interactive if the machine has several addresses)
    --do_reverse_lookup or -l : Enables reverse IP lookup feature for hops
    --size=N or -i N : number of bytes in the packet (default unknown)
    --first_hop=N or -d N : TTL/max hop count for the first hop  (default %d)
    --max_hops=N or -x N : TTL/max hop count for the last hop  (default %d)
    """ % (config.protocol, config.first_hop, config.max_hops), file=sys.stderr)

    """For "TCP Ping"
    <https://labs.ripe.net/Members/wilhelm/measuring-your-web-server-reachability-with-tcp-ping>,
    you need --protocol TCP --size=0 --port=$PORT --first_hop=64

    """

def specificParse(config, option, value):
    result = True
    if option == "--protocol" or option == "-j":
        if value.upper() != "UDP" and value.upper() != "ICMP" and value.upper() != "TCP":
            usage("Protocol must be UDP or ICMP or TCP")
            sys.exit(1)
            config.protocol = value.upper()
    elif option == "--size" or option == "-z":
        config.size = int(value)
    elif option == "--first_hop" or option == "-y":
        config.first_hop = int(value)
    elif option == "--max_hops" or option == "-x":
        config.max_hops = int(value)
    elif option == "--format" or option == "-b":
        config.format = True
    elif option == "--do_lookup" or option == "-d":
        config.do_lookup = True
    elif option == "--do_reverse_lookup" or option == "-l":
        config.do_reverse_lookup = True
    else:
        result = False
    return result
  
args = config.parse("zjxbdy", ["format", "size=", "protocol=", "first_hop=", "max_hops=",
                               "do_lookup","do_reverse_lookup"], specificParse, usage)

if len(args) != 1:
    usage()
    sys.exit(1)
target = args[0]

if config.do_lookup:
    hostname = target
    target = lookup_hostname(hostname)
    if not target:
        print(("Unknown host name \"%s\"" % hostname), file=sys.stderr)
        sys.exit(1)
        
if not is_ip_address(target):
    print(("Target must be an IP address, NOT AN HOST NAME"), file=sys.stderr)
    sys.exit(1)

data = { "is_oneoff": True,
         "definitions": [
           { "target": target, "description": "Traceroute %s" % target,
            "type": "traceroute", "protocol": config.protocol} ],
            "probes": [
             { "requested": config.requested} ] }
if config.size is not None:
    data["definitions"][0]['size'] = config.size    
if config.port is not None:
    data["definitions"][0]['port'] = config.port    
if config.first_hop is not None:
    data["definitions"][0]['first_hop'] = config.first_hop
if config.max_hops is not None:
    data["definitions"][0]['max_hops'] = config.max_hops    
if config.probes is not None:
    data["probes"][0]["type"] = "probes"
    data["probes"][0]["value"] = config.probes
else:
    if config.country is not None:
        data["probes"][0]["type"] = "country"
        data["probes"][0]["value"] = config.country
        data["definitions"][0]["description"] += (" from %s" % country)
    elif config.area is not None:
        data["probes"][0]["type"] = "area"
        data["probes"][0]["value"] = config.area
        data["definitions"][0]["description"] += (" from %s" % area)
    elif config.asn is not None:
        data["probes"][0]["type"] = "asn"
        data["probes"][0]["value"] = config.asn
        data["definitions"][0]["description"] += (" from AS #%s" % asn)
    elif config.old_measurement is not None:
        data["probes"][0]["requested"] = 1000 # Dummy value, anyway,
        # but necessary to get
        # all the probes
        # TODO: the huge value of "requested" makes us wait a very long time
        data["probes"][0]["type"] = "msm"
        data["probes"][0]["value"] = config.old_measurement
        data["definitions"][0]["description"] += (" from probes of measurement #%s" % config.old_measurement)
    else:
        data["probes"][0]["type"] = "area"
        data["probes"][0]["value"] = "WW"
    
if target.find(':') > -1:
    af = 6
else:
    af = 4
data["definitions"][0]['af'] = af
if config.measurement_id is None:
    if config.verbose:
        print(data)

    measurement = Blaeu.Measurement(data)
    print("Measurement #%s %s uses %i probes" % (measurement.id,
                                                 data["definitions"][0]["description"],
                                                 measurement.num_probes))

    rdata = measurement.results(wait=True, percentage_required=config.percentage_required)
    print(("%s probes reported" % len(rdata)))
else:
    measurement = Blaeu.Measurement(data=None, id=config.measurement_id)
    rdata = measurement.results(wait=False)
    if config.verbose:
            print("%i results from already-done measurement #%s" % (len(rdata), measurement.id))
            
print(("Test #%s done at %s" % (measurement.id, time.strftime("%Y-%m-%dT%H:%M:%SZ", measurement.time))))
if config.format: # Code stolen from json2traceroute.py
    from cymruwhois import Client

    def whoisrecord(ip):
      try:
        currenttime = time.time()
        ts = currenttime
        if ip in whois:
            ASN,ts = whois[ip]
        else:
            ts = 0
        if ((currenttime - ts) > 36000):
            c = Client()
            ASN = c.lookup(ip)
            whois[ip] = (ASN,currenttime)
        return ASN
      except Exception as e:
        return e
    
    try:
        pkl_file = open('whois.pkl', 'rb')
        whois = pickle.load(pkl_file)
    except IOError:
        whois = {}

    # Create traceroute output
    try:
        for probe in rdata:
            probefrom = probe["from"]
            if probefrom:
                    ASN = whoisrecord(probefrom)
            try:
                print("From: ",probefrom,"  ",ASN.asn,"  ",ASN.owner)
            except Exception as e:
                print("From: ", probefrom," ","AS lookup error: ",e)
            print("Source address: ",probe["src_addr"])
            print("Probe ID: ",probe["prb_id"])
            result = probe["result"]
            for proberesult in result:
                    ASN = {}
                    if "result" in proberesult:
                        print(proberesult["hop"],"  ", end=' ')
                        hopresult = proberesult["result"]
                        rtt = []
                        hopfrom = ""
                        for hr in hopresult:
                            if "error" in hr:
                                rtt.append(hr["error"])
                            elif "x" in hr:
                                rtt.append(str(hr["x"]))
                            elif "edst" in hr:
                                rtt.append("!")
                            else:
                                try:
                                    rtt.append(hr["rtt"])
                                except KeyError:
                                    rtt.append("*")
                                hopfrom = hr["from"]
                                ASN = whoisrecord(hopfrom)
                        if hopfrom:
                                  try:
                                      if not config.do_reverse_lookup:
                                              print(hopfrom, "  ", ASN.asn, "  ", ASN.owner,"  ",
                                                            end=' ')
                                      else:
                                              reverse_lookup = lookup_ip(hopfrom)
                                              print(hopfrom, "  ", reverse_lookup, "  ", ASN.asn, "  ",
                                                            ASN.owner, "  ", end=' ')
                                  except Exception as e:
                                      print("Lookup failed because of", e, "  ", end=' ')
                        print(rtt)
                    else:
                        print("Error: ", proberesult["error"])
            print("")      
    finally:
          pkl_file = open('whois.pkl', 'wb')
          pickle.dump(whois, pkl_file)
