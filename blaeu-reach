#!/usr/bin/env python3
# -*- coding: utf-8 -*-

""" Python code to start a RIPE Atlas UDM (User-Defined
Measurement). This one is for running IPv4 or IPv6 ICMP queries to
test reachability.

You'll need an API key in ~/.atlas/auth.

After launching the measurement, it downloads the results and analyzes
them.

St√©phane Bortzmeyer <stephane+frama@bortzmeyer.org>
"""

import json
import time
import os
import string
import sys
import time
import socket
import collections

import Blaeu

config = Blaeu.Config()
# Default values
config.tests = 3 # ICMP packets per probe
config.size = 64
config.by_probe = False # Default is to count by test, not by probe
config.display_probes = False
config.machine_readable = False

class Set():
    def __init__(self):
        self.failed = True
        
def is_ip_address(str):
    try:
        addr = socket.inet_pton(socket.AF_INET6, str)
    except socket.error: # not a valid IPv6 address
        try:
            addr = socket.inet_pton(socket.AF_INET, str)
        except socket.error: # not a valid IPv4 address either
            return False
    return True

def usage(msg=None):
    config.usage(msg)
    print("""Also:
    --machinereadable or -b : machine-readable output, to be consumed by tools like grep or cut
    --displayprobes or -o : display the failing probes numbers (WARNING: may create a big list)
    --tests=N or -d N : send N ICMP packets from each probe (default is %s)
    --size=N or -z N : packets of size N (in bytes, default is %s)
    --by_probe : count the percentage of success by probe, not by test (useless if --tests=1)
    """ % (config.tests, config.size), file=sys.stderr)

def specificParse(config, option, value):
    result = True
    if option == "--tests" or option == "-d":
        config.tests = int(value)
        print("DEBUG: %d tests" % config.tests)
    elif option == "--size" or option == "-z":
        config.size = int(value)
    elif option == "--by_probe":
        config.by_probe = True
    elif option == "--machinereadable" or option == "-b":
        config.machine_readable = True
    elif option == "--displayprobes" or option == "-o":
        config.display_probes = True
    else:
        result = False
    return result
    
args = config.parse("bos:d:z", ["by_probe", "tests=", "size=", "machinereadable",
                              "displayprobes"], specificParse,
                    usage)

targets = args
if len(targets) == 0:
    usage("No target found")
    sys.exit(1)
    
if config.the_probes is not None:
    requested = len(the_probes.split(","))
if config.verbose and config.machine_readable:
    usage("Specify verbose *or* machine-readable output")
    sys.exit(1)
if config.display_probes and config.machine_readable:
    usage("Display probes *or* machine-readable output")
    sys.exit(1)
data = { "is_oneoff": True,
         "definitions": [
           { "type": "ping", "packets": config.tests, "size": config.size} ],
         "probes": [
             { "requested": config.requested} ] }
data["probes"][0]["tags"] = {}
if config.include is not None:
    data["probes"][0]["tags"]["include"] = config.include
if config.exclude is not None:
    data["probes"][0]["tags"]["exclude"] = config.exclude
if config.the_probes is not None:
    data["probes"][0]["type"] = "probes"
    data["probes"][0]["value"] = the_probes
else:
    if config.country is not None:
        data["probes"][0]["type"] = "country"
        data["probes"][0]["value"] = config.country
    elif config.area is not None:
        data["probes"][0]["type"] = "area"
        data["probes"][0]["value"] = config.area
    elif config.asn is not None:
        data["probes"][0]["type"] = "asn"
        data["probes"][0]["value"] = config.asn
    elif config.prefix is not None:
        data["probes"][0]["type"] = "prefix"
        data["probes"][0]["value"] = config.prefix
    else:
        data["probes"][0]["type"] = "area"
        data["probes"][0]["value"] = "WW"

for target in targets:
    if not is_ip_address(target):
        print(("Target must be an IP address, NOT AN HOST NAME"), file=sys.stderr)
        sys.exit(1)
    data["definitions"][0]["target"] = target
    data["definitions"][0]["description"] = "Ping %s" % target
    if config.country is not None:
        data["definitions"][0]["description"] += (" from %s" % config.country)
    if config.area is not None:
        data["definitions"][0]["description"] += (" from %s" % config.area)
    if config.asn is not None:
        data["definitions"][0]["description"] += (" from AS #%s" % config.asn)
    if config.prefix is not None:
        data["definitions"][0]["description"] += (" from prefix %s" % config.prefix)
    if target.find(':') > -1:
        af = 6
        # TODO allows to specify stable probes https://labs.ripe.net/Members/chris_amin/new-ripe-atlas-probe-stability-system-tags
        if config.include is None:
            data["probes"][0]["tags"]["include"] = ["system-ipv6-works"]
    else:
        af = 4
        if config.include is None:
            data["probes"][0]["tags"]["include"] = ["system-ipv4-works"] # Some probes cannot do ICMP outgoing (firewall?)
    data["definitions"][0]['af'] = af
    if config.old_measurement is not None:
            data["probes"][0]["requested"] = 500 # Dummy value, anyway,
                                                    # but necessary to get
                                                    # all the probes
            # TODO: the huge value of "requested" makes us wait a very long time
            data["probes"][0]["type"] = "msm"
            data["probes"][0]["value"] = config.old_measurement
            data["definitions"][0]["description"] += (" from probes of measurement #%s" % config.old_measurement)
    if config.measurement_id is None:
        if config.verbose:
            print(data)
        measurement = Blaeu.Measurement(data)
        if config.old_measurement is None:
            config.old_measurement = measurement.id
        if config.verbose:
            print("Measurement #%s to %s uses %i probes" % (measurement.id, target,
                                                        measurement.num_probes))
        # Retrieve the results
        rdata = measurement.results(wait=True, percentage_required=config.percentage_required)
    else:
        measurement = Blaeu.Measurement(data=None, id=config.measurement_id)
        rdata = measurement.results(wait=False)
        if config.verbose:
            print("%i results from already-done measurement #%s" % (len(rdata), measurement.id))

    total_rtt = 0
    num_rtt = 0
    num_error = 0
    num_timeout = 0
    num_tests = 0
    if config.by_probe:
        probes_success = 0
        probes_failure = 0
        num_probes = 0
    if not config.machine_readable and config.measurement_id is None:
        print(("%s probes reported" % len(rdata)))
    if config.display_probes:
        failed_probes = collections.defaultdict(Set)
    for result in rdata:
        probe_ok = False
        probe = result["prb_id"]
        if config.by_probe:
            num_probes += 1
        for test in result["result"]:
            num_tests += 1
            if "rtt" in test:
                total_rtt += int(test["rtt"])
                num_rtt += 1
                probe_ok = True
            elif "error" in test:
                num_error += 1
            elif "x" in test:
                num_timeout += 1
            else:
                print(("Result has no field rtt, or x or error"), file=sys.stderr)
                sys.exit(1)
        if config.by_probe:
            if probe_ok:
                probes_success += 1
            else:
                probes_failure += 1
        if config.display_probes and not probe_ok:
            failed_probes[probe].failed = True
    if not config.machine_readable:
        print(("Test #%s done at %s" % (measurement.id, time.strftime("%Y-%m-%dT%H:%M:%SZ", measurement.time))))
    if num_rtt == 0:
        if not config.machine_readable:
            print("No successful test")
    else:
        if not config.machine_readable:
            if not config.by_probe:
                print(("Tests: %i successful tests (%.1f %%), %i errors (%.1f %%), %i timeouts (%.1f %%), average RTT: %i ms" % \
                    (num_rtt, num_rtt*100.0/num_tests, 
                    num_error, num_error*100.0/num_tests, 
                    num_timeout, num_timeout*100.0/num_tests, total_rtt/num_rtt)))
            else:
                print(("Tests: %i successful probes (%.1f %%), %i failed (%.1f %%), average RTT: %i ms" % \
                    (probes_success, probes_success*100.0/num_probes, 
                    probes_failure, probes_failure*100.0/num_probes, 
                    total_rtt/num_rtt)))
    if len(targets) > 1 and not config.machine_readable:
        print("")
    if config.display_probes:
        print(list(failed_probes.keys()))
    if config.machine_readable:
        if num_rtt != 0:
            percent_rtt = total_rtt/num_rtt
        else:
            percent_rtt = 0
        print(",".join([target, str(measurement.id), "%s/%s" % (len(rdata),measurement.num_probes), \
                        time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()), "%i" % num_rtt, \
                        "%.1f" % (num_rtt*100.0/num_tests), "%i" % num_error, "%.1f" % (num_error*100.0/num_tests), \
                        "%i" % num_timeout, "%.1f" % (num_timeout*100.0/num_tests), "%i" % (percent_rtt)]))
